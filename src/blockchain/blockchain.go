package blockchain

import (
	"bytes"
	"crypto/rsa"
	"encoding/base64"
)

// TARGET - A valid block hash has its first TARGET bits be zero.
const TARGET = 20

// PostBody - Part of Post used to generate a signature.
type PostBody struct {
	Content   string
	Timestamp int64
}

// Post - A user's message to be sent to the blockchain.
type Post struct {
	User      *rsa.PublicKey // user's public key
	Signature []byte         // generated by signing Body with User
	Body      PostBody       // the content of the post
}

// Verify - verifies the Post's signature matches its public key and body.
func (p *Post) Verify() bool {
	return Verify(p.User, p.Body, p.Signature)
}

// BlockHeader - Part of Block used to generate the block identity hash (the target of mining).
type BlockHeader struct {
	PrevHash  []byte // the identity hash of the previous block in a blockchain
	Summary   []byte // hash of Posts
	Timestamp int64
	Nonce     uint32 // miners find the correct Nonce when mining
}

// Block - A block in the blockchain
type Block struct {
	Header BlockHeader
	Posts  []Post // all posts contained in this block
}

// Verify - verifies if this block is valid on its own. This does not consider other blocks in the same blockchain.
func (b *Block) Verify() bool {
	hash := Hash(b.Header)
	zeroBytes := TARGET / 8
	zeroBits := TARGET % 8
	// the first zeroBytes bytes of hash must be zero
	for i := 0; i < zeroBytes; i++ {
		if hash[i] != 0 {
			return false
		}
	}
	// and then zeroBits bits of hash must be zero
	if zeroBits > 0 {
		nextByte := hash[zeroBytes]
		nextByte = nextByte >> (8 - zeroBits)
		if nextByte != 0 {
			return false
		}
	}
	// verify the summary
	if !bytes.Equal(b.Header.Summary, Hash(b.Posts)) {
		return false
	}
	// verify all posts
	for _, post := range b.Posts {
		if !post.Verify() {
			return false
		}
	}
	return true
}

// PostBase64 - base64-encoded Post to support marshalling to json.
// It is the same as Post except all []byte are encoded as base64 strings.
type PostBase64 struct {
	User      string `json:"user"`
	Content   string `json:"content"`
	Timestamp int64  `json:"timestamp"`
	Signature string `json:"signature"`
}

// EncodeBase64 - encode a Post to PostBase64.
func (p *Post) EncodeBase64() PostBase64 {
	encoded := PostBase64{
		User:      base64.StdEncoding.EncodeToString(PublicKeyToBytes(p.User)),
		Content:   p.Body.Content,
		Timestamp: p.Body.Timestamp,
		Signature: base64.StdEncoding.EncodeToString(p.Signature),
	}
	return encoded
}

// DecodeBase64 - decode a PostBase64 to a Post.
func (p *PostBase64) DecodeBase64() (Post, error) {
	decoded := Post{
		Body: PostBody{
			Content:   p.Content,
			Timestamp: p.Timestamp,
		},
	}
	// decode public key
	bytes, err := base64.StdEncoding.DecodeString(p.User)
	if err != nil {
		return Post{}, err
	}
	publicKey, err := PublicKeyFromBytes(bytes)
	if err != nil {
		return Post{}, err
	}
	decoded.User = publicKey
	// decode signature
	bytes, err = base64.StdEncoding.DecodeString(p.Signature)
	if err != nil {
		return Post{}, err
	}
	decoded.Signature = bytes
	return decoded, nil
}

// BlockBase64 - base64-encoded Block to support marshalling to json
// It is the same as Block except all []byte are encoded as base64 strings.
type BlockBase64 struct {
	PrevHash  string       `json:"prev-hash"`
	Summary   string       `json:"summary"`
	Timestamp int64        `json:"timestamp"`
	NPosts    int          `json:"n-posts"`
	Nonce     uint32       `json:"nonce"`
	Posts     []PostBase64 `json:"posts"`
}

// EncodeBase64 - encode a Block to a BlockBase64
func (b *Block) EncodeBase64() BlockBase64 {
	encoded := BlockBase64{
		PrevHash:  base64.StdEncoding.EncodeToString(b.Header.PrevHash),
		Summary:   base64.StdEncoding.EncodeToString(b.Header.Summary),
		Timestamp: b.Header.Timestamp,
		Nonce:     b.Header.Nonce,
	}
	for _, post := range b.Posts {
		encoded.Posts = append(encoded.Posts, post.EncodeBase64())
	}
	return encoded
}

// DecodeBase64 - decode a BlockBase64 to a Block
func (b *BlockBase64) DecodeBase64() (Block, error) {
	decoded := Block{
		Header: BlockHeader{
			Timestamp: b.Timestamp,
			Nonce:     b.Nonce,
		},
	}

	bytes, err := base64.StdEncoding.DecodeString(b.PrevHash)
	if err != nil {
		return Block{}, err
	}
	decoded.Header.PrevHash = bytes

	bytes, err = base64.StdEncoding.DecodeString(b.Summary)
	if err != nil {
		return Block{}, err
	}
	decoded.Header.Summary = bytes

	for _, post := range b.Posts {
		decodedPost, err := post.DecodeBase64()
		if err != nil {
			return Block{}, err
		}
		decoded.Posts = append(decoded.Posts, decodedPost)
	}
	return decoded, nil
}
